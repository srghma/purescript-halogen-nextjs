module RunAffRetry where

import Effect.Aff.Retry
import Protolude

import Data.Array (uncons)
import Effect.Aff (delay)
import Prim.Row (class Cons) as Row
import Run (Run, AFF)
import Run as Run
import Run.Except (EXCEPT)
import Run.Except as Run
import Unsafe.Coerce (unsafeCoerce)
import RunExtra

retrying
  :: ∀ b r
   . RetryPolicyM Aff
  -> (RetryStatus -> b -> Run ( aff :: AFF | r ) Boolean) -- An action to check whether the result should be retried.
                                     -- If True, we delay and retry the operation.
  -> (RetryStatus -> Run ( aff :: AFF | r ) b)            -- Action to run
  -> Run ( aff :: AFF | r ) b
retrying policy check action = go defaultRetryStatus
  where
  go status = do
    res <- action status
    ifM (check status res)
      (Run.liftAff (applyAndDelay policy status) >>= maybe (pure res) go)
      (pure res)

data Catch e a = Catch (Maybe e → a)
derive instance functorCatch ∷ Functor (Catch e)
_catch = SProxy ∷ SProxy "catch"
type CATCH e = Run.FProxy (Catch e)
type WithCatch r e  = Run.Run (catch ∷ CATCH e|r)

catch ∷ ∀ e a r. (e → WithCatch r e a) → WithCatch r e a → WithCatch r e a
catch handler attempt = do
  mbErr ← Run.lift _catch $ Catch identity
  case mbErr of
    Just e → handler e
    Nothing → attempt

reverseCatch ∷ ∀ a e r. e → WithCatch (except ∷ Run.EXCEPT e|r) e a → WithCatch (except ∷ Run.EXCEPT e|r) e Unit
reverseCatch defErr attempt = do
  mbErr ← Run.lift _catch $ Catch identity
  case mbErr of
    Just e → pure unit
    Nothing → Run.throw defErr

runCatch
  ∷ ∀ r e a
  . Run (except ∷ Run.EXCEPT e, catch ∷ CATCH e|r) a
  → Run r (Either e a)
runCatch = loop (pure <<< Left)
  where
  split =
    Run.on _catch Right
    $ Run.on Run._except
        (Left <<< Right)
        (Left <<< Left)
  loop hndl r = case Run.peel r of
    Right a →
      pure $ Right a
    Left f → case split f of
      Right (Catch cont) →
        loop (\e → loop hndl $ cont $ Just e) $ cont Nothing
      Left (Right (Run.Except err)) →
        hndl err
      Left (Left others) →
        loop hndl =<< Run.send others

runCatch' = expand' (SProxy :: SProxy "except") <<< runCatch

recovering
  :: ∀ r a e
   . RetryPolicyM Aff
  -> Array (RetryStatus -> e -> Aff Boolean)
  -> (RetryStatus -> Run ( aff :: AFF, except ∷ EXCEPT e | r ) a)
  -> Run ( aff :: AFF, except ∷ EXCEPT e | r ) a
recovering policy checks f = go defaultRetryStatus
  where
    go :: RetryStatus -> Run ( aff :: AFF, except ∷ EXCEPT e | r ) a
    go status = runCatch' (catch (recover checks) (f status))
      where
        recover
          :: Array (RetryStatus -> e -> Aff Boolean)
          -> e
          -> Run ( aff :: AFF, except ∷ EXCEPT e, catch ∷ CATCH e | r ) a
        recover chks e =
          case uncons chks of
              Nothing -> Run.throw e
              Just headTail -> handle e headTail

        handle
          :: e
          -> { head :: RetryStatus -> e -> Aff Boolean, tail :: Array (RetryStatus -> e -> Aff Boolean) }
          -> Run ( aff :: AFF, except ∷ EXCEPT e, catch ∷ CATCH e | r ) a
        handle e hs =
          Run.liftAff (hs.head status e) >>=
            if _
              then Run.liftAff (applyAndDelay policy status) >>= maybe (Run.throw e) go
              else recover hs.tail e
